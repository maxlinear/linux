// SPDX-License-Identifier: GPL-2.0
/******************************************************************************
 *
 * Copyright (c) 2020 - 2023 MaxLinear, Inc.
 * Copyright (c) 2020 Intel Corporation
 *
 *****************************************************************************/

#include <linux/netdevice.h>
#include <linux/types.h>
#include <linux/version.h>
#include <net/datapath_api.h>
#include <net/pkt_cls.h>
#include <net/datapath_api_qos.h>
#include <net/switch_api/lantiq_gsw_flow.h>
#include "qos_tc_compat.h"
#include "qos_tc_flower.h"
#include "qos_tc_vlan_prepare.h"
#include "qos_tc_pce.h"
#include "qos_tc_trap.h"
#include "qos_tc_parser.h"
#include "qos_tc_qos.h"

LIST_HEAD(tc_trap_storage);

struct pce_rule_storage {
	/** TC command handle used as dual identificator */
	unsigned long cookie;
	/** TC command preference used as dual identificator */
	int pref;
	/** Logical Port Id. The valid range is hardware dependent */
	u32 logicalportid;
	/** Sub interface ID group,
	 *  The valid range is hardware/protocol dependent
	 */
	u32 subifidgroup;
	/** PCE TABLE Region */
	GSW_PCE_RuleRegion_t	region;
	/** Rule Index in the PCE Table */
	u32	nIndex;
	/** Sub-Block Type ID */
	int	subblk_id;
	struct list_head list;
};

/* If CONFIG_MXL_ETHSW_NOSPTAG is set additional rules are created to trap
 * packets to the CPU. These are the rules created on the pon0 interface.
 * Add more space for these additional rules.
 */
#if defined(CONFIG_MXL_ETHSW_NOSPTAG)
#define TC_TRAP_SUBBLK_SIZE 40
#else
#define TC_TRAP_SUBBLK_SIZE 32
#endif

static void qos_tc_trap_set_default(struct net_device *dev,
				    GSW_PCE_rule_t *pce_rule,
				    struct dp_pce_blk_info *pce_blk_info)
{
	struct pce_rule_storage *p;

	/* Set default values for trap action */
	pce_rule->action.ePortMapAction = GSW_PCE_ACTION_PORTMAP_CPU;
	pce_rule->pattern.bEnable = 1;
	pce_rule->pattern.bInsertionFlag_Enable = 1;
	/* INS=2 means match on no special tag (set for LAN ports). */
	if (IS_ENABLED(CONFIG_MXL_ETHSW_NOSPTAG) && qos_tc_is_lan_dev(dev))
		pce_rule->pattern.nInsertionFlag = GSW_PCE_INSERT_MATCH_NO_STAG;
	else
		pce_rule->pattern.nInsertionFlag =
			GSW_PCE_INSERT_MATCH_NO_INSERT_FLAG;
	pce_rule->pattern.bSLAN_Vid = 0;
	pce_rule->region = GSW_PCE_RULE_COMMMON;

	pce_blk_info->region = pce_rule->region;
	pce_blk_info->info.subblk_size = TC_TRAP_SUBBLK_SIZE;
	strncpy(pce_blk_info->info.subblk_name, "TRAP",
		sizeof(pce_blk_info->info.subblk_name));

	/* All PCE rules for trap action should be put in the same subblock,
	 * take subblk_id from the first rule on the list. If there are no
	 * rules in storage, leave subblk_id equal to 0, to make DP create new
	 * subblock for trap action rules. */
	list_for_each_entry(p, &tc_trap_storage, list) {
		pce_blk_info->info.subblk_id = p->subblk_id;
	}

	return;
}

static int qos_tc_trap_storage_add(struct net_device *dev,
				   GSW_PCE_rule_t *pce_rule,
				   struct dp_pce_blk_info *pce_blk_info,
				   unsigned long cookie,
				   int pref)
{
	struct pce_rule_storage *pce_rule_storage;

	pce_rule_storage = kzalloc(sizeof(*pce_rule_storage), GFP_KERNEL);
	if (!pce_rule_storage)
		return -ENOMEM;

	pce_rule_storage->cookie = cookie;
	pce_rule_storage->pref = pref;
	pce_rule_storage->nIndex = pce_rule->pattern.nIndex;
	pce_rule_storage->logicalportid = pce_rule->logicalportid;
	pce_rule_storage->subifidgroup = pce_rule->subifidgroup;
	pce_rule_storage->region = pce_blk_info->region;
	pce_rule_storage->subblk_id = pce_blk_info->info.subblk_id;

	list_add(&pce_rule_storage->list, &tc_trap_storage);

	return 0;
}

/* Additional rule to trap when Special Tag is not generated by HW */
static int qos_tc_trap_rule_apply(struct net_device *dev,
				  GSW_PCE_rule_t *pce_rule,
				  struct dp_pce_blk_info *pce_blk_info,
				  unsigned long cookie,
				  int pref)
{
	GSW_PCE_ruleDelete_t pce_rule_del = {0};
	int ret, index;

	index = dp_pce_rule_add(pce_blk_info, pce_rule);
	if (index < 0) {
		netdev_err(dev, "%s: dp_pce_rule_add failed err %d\n",
			   __func__, index);
		return -EINVAL;
	}
	netdev_dbg(dev, "%s: pce rule added with index %d\n", __func__, index);

	/* Save data needed for rule deletion */
	ret = qos_tc_trap_storage_add(dev, pce_rule, pce_blk_info, cookie,
				      pref);
	if (ret) {
		pce_rule_del.logicalportid = pce_rule->logicalportid;
		pce_rule_del.subifidgroup = pce_rule->subifidgroup;
		pce_rule_del.region = pce_rule->region;
		pce_rule_del.nIndex = pce_rule->pattern.nIndex;
		dp_pce_rule_del(pce_blk_info, &pce_rule_del);
	}

	return ret;
}

/* Add a second PCE rule without a special tag for rules created on the pon0
 * device when CONFIG_MXL_ETHSW_NOSPTAG is set.
 * The rules on the pon0 device are for all packets going to the CPU. The pon0
 * device is detected by checking for bPortIdEnable. This is not set for the
 * pon0 device, but for all others. The PON ports on the GSWIP are using a
 * special tag and the LAN ports are not suing a special tag when
 * CONFIG_MXL_ETHSW_NOSPTAG is set.
 */
static int qos_tc_trap_nosptag(struct net_device *dev,
			       GSW_PCE_rule_t *pce_rule,
			       struct dp_pce_blk_info *pce_blk_info,
			       unsigned long cookie,
			       int pref)
{
	if (!IS_ENABLED(CONFIG_MXL_ETHSW_NOSPTAG))
		return 0;

	if (pce_rule->pattern.bPortIdEnable)
		return 0;

	/* INS=2 means match on no special tag (set for LAN ports). */
	pce_rule->pattern.nInsertionFlag = GSW_PCE_INSERT_MATCH_NO_STAG;

	return qos_tc_trap_rule_apply(dev, pce_rule, pce_blk_info, cookie,
				      pref);
}

int qos_tc_trap_offload(struct net_device *dev,
			struct flow_cls_offload *f,
			unsigned long cookie)
{
	struct dp_pce_blk_info *pce_blk_info;
	GSW_PCE_rule_t *pce_rule;
	int pref = f->common.prio >> 16;
	int ret;

	pce_rule = kzalloc(sizeof(*pce_rule), GFP_ATOMIC);
	if (!pce_rule)
		return -ENOMEM;

	pce_blk_info = kzalloc(sizeof(*pce_blk_info), GFP_ATOMIC);
	if (!pce_blk_info) {
		kfree(pce_rule);
		return -ENOMEM;
	}

	qos_tc_trap_set_default(dev, pce_rule, pce_blk_info);

	ret = qos_tc_to_pce(dev, f, pce_rule);
	if (ret != 0) {
		kfree(pce_rule);
		kfree(pce_blk_info);
		return ret;
	}

	netdev_dbg(dev, "%s: PCE rule prepared\n", __func__);

	pce_blk_info->info.portid = pce_rule->pattern.nPortId;
	pce_blk_info->info.subif = pce_rule->pattern.nSubIfId;

	ret = qos_tc_trap_rule_apply(dev, pce_rule, pce_blk_info, cookie, pref);
	if (ret != DP_SUCCESS) {
		kfree(pce_rule);
		kfree(pce_blk_info);
		return ret;
	}

	ret = qos_tc_trap_nosptag(dev, pce_rule, pce_blk_info, cookie, pref);
	if (ret < 0) {
		netdev_err(dev, "%s: qos_tc_trap_nosptag failed err %d\n",
			   __func__, ret);
		qos_tc_trap_unoffload(dev, f, cookie);
		kfree(pce_rule);
		kfree(pce_blk_info);
		return ret;
	}

	kfree(pce_rule);
	kfree(pce_blk_info);

	ret = qos_tc_flower_storage_add(dev, f->cookie, TC_TYPE_TRAP,
					NULL, NULL);
	if (ret < 0)
		qos_tc_trap_unoffload(dev, f, cookie);

	return 0;
}

static int qos_tc_trap_storage_del(struct net_device *dev,
				   struct pce_rule_storage *p)
{
	struct dp_pce_blk_info pce_blk_info = {0};
	GSW_PCE_ruleDelete_t pce_rule = {0};
	int ret;

	pce_rule.logicalportid = p->logicalportid;
	pce_blk_info.info.portid = p->logicalportid;
	netdev_dbg(dev, "%s: logicalportid  = %d\n", __func__,
		   pce_rule.logicalportid);

	pce_rule.subifidgroup = p->subifidgroup;
	pce_blk_info.info.subif = p->subifidgroup;
	netdev_dbg(dev, "%s: subifidgroup  = %d\n", __func__,
		   pce_rule.subifidgroup);

	pce_rule.region = p->region;
	pce_blk_info.region = p->region;
	netdev_dbg(dev, "%s: region  = %d\n", __func__,
		   pce_rule.region);

	pce_rule.nIndex = p->nIndex;
	netdev_dbg(dev, "%s: nIndex  = %d\n", __func__,
		   pce_rule.nIndex);

	pce_blk_info.info.subblk_id = p->subblk_id;
	netdev_dbg(dev, "%s: subblk_id  = %d\n", __func__,
		   pce_blk_info.info.subblk_id);

	ret = dp_pce_rule_del(&pce_blk_info, &pce_rule);
	if (ret < 0) {
		netdev_err(dev, "%s: dp_pce_rule_del failed err %d\n",
			   __func__, ret);
		return ret;
	}
	netdev_dbg(dev, "%s: deleted pce rule with index %d\n", __func__,
		   pce_rule.nIndex);

	list_del(&p->list);
	kfree(p);

	return 0;
}

int qos_tc_trap_unoffload(struct net_device *dev,
			  struct flow_cls_offload *f,
			  unsigned long cookie)
{
	struct pce_rule_storage *p, *n;
	int pref = f->common.prio >> 16;
	int ret = -EINVAL;

	list_for_each_entry_safe(p, n, &tc_trap_storage, list) {
		if (cookie == p->cookie && pref == p->pref) {
			ret = qos_tc_trap_storage_del(dev, p);
			if (ret != 0)
				break;
		}
	}

	return ret;
}

static void print_pce_rule_storage(struct seq_file *file,
				   struct pce_rule_storage *p)
{
	seq_printf(file, "nIndex: %u\n", p->nIndex);

	seq_printf(file, "cookie: %#lx\n", p->cookie);
	seq_printf(file, "pref: %d\n", p->pref);
	seq_printf(file, "logicalportid: %u\n", p->logicalportid);
	seq_printf(file, "subifidgroup: %u\n", p->subifidgroup);

	switch (p->region) {
	case GSW_PCE_RULE_COMMMON:
		seq_puts(file, "region: GSW_PCE_RULE_COMMMON\n");
		break;
	case GSW_PCE_RULE_CTP:
		seq_puts(file, "region: GSW_PCE_RULE_CTP\n");
		break;
	case GSW_PCE_RULE_DEBUG:
		seq_puts(file, "region: GSW_PCE_RULE_DEBUG\n");
		break;
	default:
		seq_puts(file, "region: unknown\n");
		break;
	}

	seq_printf(file, "subblk_id: %d\n", p->subblk_id);

	seq_puts(file, "\n");
}

void qos_tc_trap_storage_debugfs(struct seq_file *file, void *ctx)
{
	struct pce_rule_storage *p;

	rtnl_lock();
	list_for_each_entry(p, &tc_trap_storage, list) {
		print_pce_rule_storage(file, p);
	}
	rtnl_unlock();
}
